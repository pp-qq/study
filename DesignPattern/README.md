# デザインパターン

## 生成パターン

### Factory パターン

スーパークラスでオブジェクトを作成するためのインターフェースを決めている。サブクラスでは作成するオブジェクトの値や型を変更することができる。

### Builder パターン

複雑なオブジェクトを段階的に構築する。同じ構築コードを使用して異なる型と表現のオブジェクトを生成することができる。

例えば、多くのフィールドなどが入れ子になったオブジェクトがあり、面倒な段階的初期化が必要なオブジェクトに対して有効。House オブジェクトを生成したい場合、hasGarage, hasSwimPool, hasStatues、など引数が多い場合、コンストラクタ呼び出しが巨大になってしまう。これを防ぐことができる。

さらにディレクタークラスを定義して、オブジェクト構築に使用する一連の構築ステップを抽象化することができる。例えば構築ステップを実行する順番を定義する。

### Singleton パターン

クラスが一つのインスタンスのみを持つことを保証し、その唯一のインスタンスへの大域的なアクセスを提供する。

例えばデータベースやファイルなどの共有資源へのアクセスを制御する際などにインスタンス数を管理する必要がある。

またそのインスタンスに対するアクセスや変更処理を提供する実装することで、そのインスタンスに対す変更処理を一箇所にまとめることができる。（一つしか作らない重要なインスタンスに対する変更処理をコードのいろいろな場所にばら撒くのを防ぐ）

## 振舞パターン

### Obserber / PubSub パターン

観察対象オブジェクトに何かイベントが発生した時、そのイベントの観察者である複数のオブジェクトに通知を行う。

### Iterator パターン

リスト、スタック、ツリーなどのデータ表現を表に出さずにコレクションの要素を探索することができる。

### Strategy パターン

定義したストラテジーに基づいて、異なる動作をしたり、異なるメソッドを呼び出したりする。この時、それぞれのアルゴリズムをクラスとしてオブジェクトを交換可能にする。

## 構造パターン

### Facade パターン

ライブラリー、フレームワーク、その他のクラスの複雑な組み合わせに対し、簡素化されたインターフェースを提供できる。

例えば、店に電話して注文をする際、電話オペレータはすべてのサービスやデパートに対するファサードである。オペレータは、注文システム、支払い、配達サービスに対して簡単な音声インターフェースを提供する。

### Adapter パターン

非互換なインターフェースのオブジェクト同士を繋げる。

## 参照

- https://refactoring.guru/ja/design-patterns/catalog
